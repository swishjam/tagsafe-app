"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Perfume.js v8.0.0 (http://zizzamia.github.io/perfume)
 * Copyright 2022 Leonardo Zizzamia (https://github.com/Zizzamia/perfume.js/graphs/contributors)
 * Licensed under MIT (https://github.com/Zizzamia/perfume.js/blob/master/LICENSE)
 *
 * @license
 */
var config_1 = require("./config");
var constants_1 = require("./constants");
var getNavigationTiming_1 = require("./getNavigationTiming");
var getNetworkInformation_1 = require("./getNetworkInformation");
var isSupported_1 = require("./isSupported");
var log_1 = require("./log");
var measure_1 = require("./measure");
var metrics_1 = require("./metrics");
var observe_1 = require("./observe");
var storageEstimate_1 = require("./storageEstimate");
var utils_1 = require("./utils");
var vitalsScore_1 = require("./vitalsScore");
var ntbtTimeoutID = 0;
var Perfume = /** @class */ (function () {
    function Perfume(options) {
        if (options === void 0) { options = {}; }
        this.v = '8.0.0';
        // Extend default config with external options
        config_1.config.analyticsTracker = options.analyticsTracker;
        config_1.config.isResourceTiming = !!options.resourceTiming;
        config_1.config.isElementTiming = !!options.elementTiming;
        config_1.config.maxTime = options.maxMeasureTime || config_1.config.maxTime;
        // Exit from Perfume when basic Web Performance APIs aren't supported
        if (!(0, isSupported_1.isPerformanceSupported)()) {
            return;
        }
        // Checks if use Performance or the EmulatedPerformance instance
        if ('PerformanceObserver' in constants_1.W) {
            (0, observe_1.initPerformanceObserver)();
        }
        var navigationTiming = (0, getNavigationTiming_1.getNavigationTiming)();
        // Log Navigation Timing
        (0, log_1.logData)('navigationTiming', navigationTiming);
        if (navigationTiming.redirectTime) {
            (0, log_1.logMetric)({
                attribution: {},
                name: "RT",
                rating: (0, vitalsScore_1.getVitalsScore)('RT', navigationTiming.redirectTime),
                value: navigationTiming.redirectTime,
            });
        }
        // Log Network Information
        (0, log_1.logData)('networkInformation', (0, getNetworkInformation_1.getNetworkInformation)());
        // Let's estimate our storage capacity
        if (constants_1.WN && constants_1.WN.storage && typeof constants_1.WN.storage.estimate === 'function') {
            constants_1.WN.storage.estimate().then(storageEstimate_1.reportStorageEstimate);
        }
    }
    /**
     * Start performance measurement
     */
    Perfume.prototype.start = function (markName) {
        if (!(0, isSupported_1.isPerformanceSupported)() || metrics_1.metrics[markName]) {
            return;
        }
        metrics_1.metrics[markName] = true;
        // Creates a timestamp in the browser's performance entry buffer
        constants_1.WP.mark("mark_".concat(markName, "_start"));
    };
    /**
     * End performance measurement
     */
    Perfume.prototype.end = function (markName, customProperties, doLogData) {
        if (customProperties === void 0) { customProperties = {}; }
        if (doLogData === void 0) { doLogData = true; }
        if (!(0, isSupported_1.isPerformanceSupported)() || !metrics_1.metrics[markName]) {
            return;
        }
        // End Performance Mark
        constants_1.WP.mark("mark_".concat(markName, "_end"));
        delete metrics_1.metrics[markName];
        var measure = (0, measure_1.performanceMeasure)(markName);
        if (doLogData) {
            (0, log_1.logData)(markName, (0, utils_1.roundByFour)(measure), customProperties);
        }
    };
    /**
     * End performance measurement after first paint from the beging of it
     */
    Perfume.prototype.endPaint = function (markName, customProperties) {
        var _this = this;
        setTimeout(function () {
            _this.end(markName, customProperties);
        });
    };
    /**
     * Removes the named mark from the browser's performance entry buffer.
     */
    Perfume.prototype.clear = function (markName) {
        delete metrics_1.metrics[markName];
        // Mobile Safari v13 and UC Browser v11
        // don't support clearMarks yet
        if (!constants_1.WP.clearMarks) {
            return;
        }
        constants_1.WP.clearMarks("mark_".concat(markName, "_start"));
        constants_1.WP.clearMarks("mark_".concat(markName, "_end"));
    };
    /**
     * NTBT = Navigation Total Blocking Time
     *
     * This metric measures the amount of time the application may be blocked
     * from processing code during the 2s window after a user navigates
     * from page A to page B.
     *
     * Because this library is navigation agnostic, we have this method
     * to mark when the navigation starts.
     *
     * The NTBT metric is the summation of the blocking time of all long tasks
     * in the 2s window after this method is invoked.
     *
     * If this method is called before the 2s window ends; it will trigger a new
     * NTBT measurement and interrupt the previous one.
     *
     * Credit: Thank you Steven Lam for helping with this!
     */
    Perfume.prototype.markNTBT = function () {
        var _this = this;
        this.start('ntbt');
        // Reset NTBT value
        metrics_1.ntbt.value = 0;
        clearTimeout(ntbtTimeoutID);
        // @ts-ignore
        ntbtTimeoutID = setTimeout(function () {
            _this.end('ntbt', {}, false);
            (0, log_1.logMetric)({
                attribution: {},
                name: "NTBT",
                rating: (0, vitalsScore_1.getVitalsScore)('NTBT', metrics_1.ntbt.value),
                value: metrics_1.ntbt.value,
            });
            metrics_1.ntbt.value = 0;
        }, 2000);
    };
    return Perfume;
}());
exports.default = Perfume;
//# sourceMappingURL=perfume.js.map