/**
 * Perfume.js v8.0.0 (http://zizzamia.github.io/perfume)
 * Copyright 2022 Leonardo Zizzamia (https://github.com/Zizzamia/perfume.js/graphs/contributors)
 * Licensed under MIT (https://github.com/Zizzamia/perfume.js/blob/master/LICENSE)
 *
 * @license
 */
import { config } from './config';
import { W, WN, WP } from './constants';
import { getNavigationTiming } from './getNavigationTiming';
import { getNetworkInformation } from './getNetworkInformation';
import { isPerformanceSupported } from './isSupported';
import { logData, logMetric } from './log';
import { performanceMeasure } from './measure';
import { metrics, ntbt } from './metrics';
import { initPerformanceObserver } from './observe';
import { reportStorageEstimate } from './storageEstimate';
import { roundByFour } from './utils';
import { getVitalsScore } from './vitalsScore';
var ntbtTimeoutID = 0;
var Perfume = /** @class */ (function () {
    function Perfume(options) {
        if (options === void 0) { options = {}; }
        this.v = '8.0.0';
        // Extend default config with external options
        config.analyticsTracker = options.analyticsTracker;
        config.isResourceTiming = !!options.resourceTiming;
        config.isElementTiming = !!options.elementTiming;
        config.maxTime = options.maxMeasureTime || config.maxTime;
        // Exit from Perfume when basic Web Performance APIs aren't supported
        if (!isPerformanceSupported()) {
            return;
        }
        // Checks if use Performance or the EmulatedPerformance instance
        if ('PerformanceObserver' in W) {
            initPerformanceObserver();
        }
        var navigationTiming = getNavigationTiming();
        // Log Navigation Timing
        logData('navigationTiming', navigationTiming);
        if (navigationTiming.redirectTime) {
            logMetric({
                attribution: {},
                name: "RT",
                rating: getVitalsScore('RT', navigationTiming.redirectTime),
                value: navigationTiming.redirectTime,
            });
        }
        // Log Network Information
        logData('networkInformation', getNetworkInformation());
        // Let's estimate our storage capacity
        if (WN && WN.storage && typeof WN.storage.estimate === 'function') {
            WN.storage.estimate().then(reportStorageEstimate);
        }
    }
    /**
     * Start performance measurement
     */
    Perfume.prototype.start = function (markName) {
        if (!isPerformanceSupported() || metrics[markName]) {
            return;
        }
        metrics[markName] = true;
        // Creates a timestamp in the browser's performance entry buffer
        WP.mark("mark_".concat(markName, "_start"));
    };
    /**
     * End performance measurement
     */
    Perfume.prototype.end = function (markName, customProperties, doLogData) {
        if (customProperties === void 0) { customProperties = {}; }
        if (doLogData === void 0) { doLogData = true; }
        if (!isPerformanceSupported() || !metrics[markName]) {
            return;
        }
        // End Performance Mark
        WP.mark("mark_".concat(markName, "_end"));
        delete metrics[markName];
        var measure = performanceMeasure(markName);
        if (doLogData) {
            logData(markName, roundByFour(measure), customProperties);
        }
    };
    /**
     * End performance measurement after first paint from the beging of it
     */
    Perfume.prototype.endPaint = function (markName, customProperties) {
        var _this = this;
        setTimeout(function () {
            _this.end(markName, customProperties);
        });
    };
    /**
     * Removes the named mark from the browser's performance entry buffer.
     */
    Perfume.prototype.clear = function (markName) {
        delete metrics[markName];
        // Mobile Safari v13 and UC Browser v11
        // don't support clearMarks yet
        if (!WP.clearMarks) {
            return;
        }
        WP.clearMarks("mark_".concat(markName, "_start"));
        WP.clearMarks("mark_".concat(markName, "_end"));
    };
    /**
     * NTBT = Navigation Total Blocking Time
     *
     * This metric measures the amount of time the application may be blocked
     * from processing code during the 2s window after a user navigates
     * from page A to page B.
     *
     * Because this library is navigation agnostic, we have this method
     * to mark when the navigation starts.
     *
     * The NTBT metric is the summation of the blocking time of all long tasks
     * in the 2s window after this method is invoked.
     *
     * If this method is called before the 2s window ends; it will trigger a new
     * NTBT measurement and interrupt the previous one.
     *
     * Credit: Thank you Steven Lam for helping with this!
     */
    Perfume.prototype.markNTBT = function () {
        var _this = this;
        this.start('ntbt');
        // Reset NTBT value
        ntbt.value = 0;
        clearTimeout(ntbtTimeoutID);
        // @ts-ignore
        ntbtTimeoutID = setTimeout(function () {
            _this.end('ntbt', {}, false);
            logMetric({
                attribution: {},
                name: "NTBT",
                rating: getVitalsScore('NTBT', ntbt.value),
                value: ntbt.value,
            });
            ntbt.value = 0;
        }, 2000);
    };
    return Perfume;
}());
export default Perfume;
//# sourceMappingURL=perfume.js.map